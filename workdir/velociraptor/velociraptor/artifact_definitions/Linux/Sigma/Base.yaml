name: Linux.Sigma.Base
parameters:
  - name: ROOT
    description: The Event Log Directory we use to read all logs
    default: /var/log/
  - name: Debug
    type: bool
    description: Enable full debug trace
  - name: RuleLevel
    type: choices
    default: All
    choices:
      - Critical
      - Critical and High
      - All

  - name: DefaultYear
    description: The Default year for parsing Syslog timestamps (default current year)

  - name: RuleStatus
    type: choices
    default: All Rules
    choices:
      - Stable
      - Stable and Experimental
      - Stable and Test
      - All Rules

  - name: RuleExclusions
    type: csv
    description: |
      This table are rules that will be excluded by Title Regex
    default: |
      RuleTitleRegex,Reason
      noisy,All rules marked noisy should be disabled by default.

  - name: RuleTitleFilter
    type: regex
    default: .
    description: Use this to filter only some rules to match
export: |
  LET X = scope()
  LET Hostname <= dict(H={ SELECT Hostname FROM info()}).H[0].Hostname

  LET ExcludeRegex <= if(condition=X.RuleExclusions,
       then=join(array=RuleExclusions.RuleTitleRegex, sep="|"),
       else="XXXXXXX")

  LET RuleStatusRegex <= get(item=dict(
       `Stable`="stable",
       `Stable and Experimental`="stable|experimental",
       `Stable and Test`="stable|test",
       `All Rules`="."), member=RuleStatus)

  LET RuleLevelRegex <= get(item=dict(
       Critical="critical",
       `Critical and High`="critical|high",
       `All`="."), member=RuleLevel)

  LET ParseLogFile(Filter, ROOT) =
      SELECT OSPath.Basename AS Channel, Line FROM foreach(row={
         SELECT OSPath FROM glob(globs="*", root=ROOT)
         WHERE OSPath.Basename =~ Filter
      }, query={
         SELECT OSPath, Line
         FROM parse_lines(filename=OSPath)
      })

  LET ParseAuditdLogFile(Filter, ROOT) =
      SELECT OSPath.Basename AS Channel, * FROM foreach(row={
         SELECT OSPath FROM glob(globs="*", root=ROOT)
         WHERE OSPath.Basename =~ Filter
      }, query={
         SELECT OSPath, *
         FROM parse_auditd(filename=OSPath)
      })

  -- Used to parse syslog lines
  LET DefaultYear <= format(format=" %v", args=DefaultYear || timestamp(epoch=now()).Year)

  LET FieldMapping <= parse_json(data=gunzip(string=base64decode(string="H4sIAAAAAAAA/3TS3WrrMAwH8FcJuuoBY9JvOJCr88EKY5SSXS1jiFSkpokdbBUSxvbsw94KdVtfBaQf/yBZ7wC/YSiqU57PaQABf0zXod4/Kk2XHbm1pibnJCtuCQT8JcdKIyujH4xjjd2lPxjHE18rBumlVL3IeOypqGBb7ioQGVusj2TfjG7Hotw9//sVp2766P8/KbHZGsu3qvdVAZsOm/sz0OAn2GjFCpn2kXkilntlqfb5WfGZVUCNJecqAAEl2ob4v2rpauBB+qLskQ8gAPO7/0XbuJf81YNpGkwDmKXBLIB5GswDWKTBIoBlGiwDWKXBKoB1Gqw9qE3X3SVhewL8Q6Qf6Ehj1C3xvL6b5V/l+o+/ttggH75FaAlwo6uxbeMDQkZ5bgi4Cjn1NTqaOLZKN8Ugy7Enf7Ynrfg2JlQ/vgIAAP//wZm7xWIDAAA=")))

  LET DefaultDetails <= parse_json(data=gunzip(string=base64decode(string="H4sIAAAAAAAA/6pWclSyUqqwjSk1MDBOrdDzycxLVaoFBAAA//+eso6mFgAAAA==")))

  LET ParseTimestamp(Line) = grok(grok="%{SYSLOGTIMESTAMP:timestamp}", data=Line)

  
  LET LogSources <= sigma_log_sources(
  
    `*/linux/*`={
     SELECT * FROM ParseLogFile(ROOT=ROOT, Filter="auth.log|syslog|secure")
    },
    `*/linux/sshd`={
     SELECT * FROM ParseLogFile(ROOT=ROOT, Filter="auth.log|secure")
     WHERE Line =~ "sshd"
    },
    `*/linux/cron`={
     SELECT * FROM ParseLogFile(ROOT=ROOT, Filter="syslog")
     WHERE Line =~ "cron"
    },
    `*/linux/auth`={
     SELECT * FROM ParseLogFile(ROOT=ROOT, Filter="auth.log|secure")
    },
    `*/linux/syslog`={
     SELECT * FROM ParseLogFile(ROOT=ROOT, Filter="syslog")
    },
    `*/linux/sudo`={
     SELECT * FROM ParseLogFile(ROOT=ROOT, Filter="auth.log|secure")
     WHERE Line =~ "sudo:"
    },
    `*/linux/auditd`={
     SELECT * FROM AuditdEvents
    },
    `network_connection/linux/*`={
     SELECT * FROM AuditdEvents
     WHERE Summary.action = "connected-to"
    },
    `process_creation/linux/*`={
     SELECT * FROM ParseAuditdLogFile(ROOT=ROOT + "/audit/", Filter="audit.log")
    },`velociraptor/info/*`={ SELECT * FROM info() })
  

  LET FieldMapping <= parse_json(data=gunzip(string=base64decode(string="H4sIAAAAAAAA/3TS3WrrMAwH8FcJuuoBY9JvOJCr88EKY5SSXS1jiFSkpokdbBUSxvbsw94KdVtfBaQf/yBZ7wC/YSiqU57PaQABf0zXod4/Kk2XHbm1pibnJCtuCQT8JcdKIyujH4xjjd2lPxjHE18rBumlVL3IeOypqGBb7ioQGVusj2TfjG7Hotw9//sVp2766P8/KbHZGsu3qvdVAZsOm/sz0OAn2GjFCpn2kXkilntlqfb5WfGZVUCNJecqAAEl2ob4v2rpauBB+qLskQ8gAPO7/0XbuJf81YNpGkwDmKXBLIB5GswDWKTBIoBlGiwDWKXBKoB1Gqw9qE3X3SVhewL8Q6Qf6Ehj1C3xvL6b5V/l+o+/ttggH75FaAlwo6uxbeMDQkZ5bgi4Cjn1NTqaOLZKN8Ugy7Enf7Ynrfg2JlQ/vgIAAP//wZm7xWIDAAA=")))

  LET DefaultDetails <= parse_json(data=gunzip(string=base64decode(string="H4sIAAAAAAAA/6pWclSyUqqwjSk1MDBOrdDzycxLVaoFBAAA//+eso6mFgAAAA==")))

  LET DefaultDetailsLambda = '''x=>x.Line'''
  LET RuleFilterLambda = '''x=>x.Level =~ RuleLevelRegex AND x.Status =~ RuleStatusRegex AND x.Title =~ RuleTitleFilter AND NOT x.Title =~ ExcludeRegex'''

  LET AuditdEvents = generate(name="Auditd Events", query={
    SELECT * FROM ParseAuditdLogFile(ROOT=ROOT + "/audit/", Filter="audit.log")
  })
sources:
- query: |
    SELECT Timestamp,
           Hostname AS Computer,
           Channel,
           _Rule.Level AS Level,
           _Rule.Title AS Title,
           Details,
           *
    FROM sigma(
       rules=split(string= Rules, sep="\n---+\r?\n"),
       log_sources= LogSources, debug=Debug,
       default_details=DefaultDetailsLambda,
       rule_filter=RuleFilterLambda,
       field_mapping= FieldMapping)
